{"meta":{"title":"小飒的博客","subtitle":"NiceBlueChai","description":"有些美好的东西，总于指尖悄悄流去……","author":"NiceBlueChai","url":"http://yoursite.com"},"pages":[{"title":"关于","date":"2018-02-24T07:45:29.000Z","updated":"2018-02-24T07:46:51.126Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"All categories","date":"2018-02-23T14:18:05.000Z","updated":"2018-02-24T07:37:23.015Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"photo","date":"2018-02-24T07:47:46.000Z","updated":"2018-02-24T07:58:38.872Z","comments":false,"path":"photo/index.html","permalink":"http://yoursite.com/photo/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-02-23T14:13:12.000Z","updated":"2018-02-24T07:36:59.451Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-02-23T14:13:12.000Z","updated":"2018-02-23T14:15:29.649Z","comments":true,"path":"tags/随笔/index.html","permalink":"http://yoursite.com/tags/随笔/index.html","excerpt":"","text":""}],"posts":[{"title":"Qt-使用工作线程","slug":"使用工作线程","date":"2018-04-07T07:02:02.599Z","updated":"2018-04-07T07:33:19.872Z","comments":true,"path":"2018/04/07/使用工作线程/","link":"","permalink":"http://yoursite.com/2018/04/07/使用工作线程/","excerpt":"","text":"comments: false&gt;在Qt里，线程相关的类： QThread 线程 QMutex 互斥锁QSemaphore 信号量 “工作线程”:就是一个普通的线程,区别于”界面线程”当一个事件处理可能需要较长时间,就创建一个工作线程处理它,以避免界面卡死. 步骤:(1) 启动一个工作线程(2) 显示一个进度条或对等待话框(3) 启动一个定时器,定时查询工作线程的进度和状态,在其完成之后,填满进度条、结束等待. 创建线程派生一个线程类12345678class MyThread : public QThread&#123;Q_OBJECTpublic:MyThread(QObject *parent);~MyThread();void run(); // 线程的入口函数&#125;; 添加一些成员函数，用于查询任务的状态和进度 :状态：int GetStatus();已完成(1)正在进行(0)发生错误，已终止(‐1)进度：int GetProgress();0‐100 启动线程12MyTask* m_task = new MyTask();m_task‐&gt;start(); 回收线程1m_task-&gt;wait();","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"线程","slug":"线程","permalink":"http://yoursite.com/tags/线程/"},{"name":"工作线程","slug":"工作线程","permalink":"http://yoursite.com/tags/工作线程/"}]},{"title":"定时器Timer","slug":"定时器Timer","date":"2018-04-07T07:02:02.597Z","updated":"2018-04-07T07:18:47.100Z","comments":false,"path":"2018/04/07/定时器Timer/","link":"","permalink":"http://yoursite.com/2018/04/07/定时器Timer/","excerpt":"","text":"###定时器用于实现定时操作，如： 每三分钟保存一次 每500毫秒闪烁一次 每1秒刷新一次界面 新建Timer (1) 重写timeEvent()函数virtual void timerEvent ( QTimerEvent * event );123456789// 定时器处理函数void Test8_2A::timerEvent ( QTimerEvent * event )&#123;// 可以有多个定时器，每个的定时器有不同的处理 if(event‐&gt;timerId() == m_timerId) &#123; &#125;&#125; (2) 启动定时器，指定时间间隔m_timerId=startTime(500); 例子：实现一个文字时钟，显示系统当前时间 1234567891011121314151617Timer_Event::Timer_Event(QWidget *parent) : QMainWindow(parent)&#123; ui.setupUi(this); m_timerId = startTimer(1000);&#125;void Timer_Event::timerEvent(QTimerEvent *event)&#123; if (event-&gt;timerId()==m_timerId) &#123; QTime now = QTime::currentTime(); QString text = now.toString(&quot;HH:mm:ss ap&quot;); ui.labelTime-&gt;setText(text); &#125; &#125; ❤️","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"Timer","slug":"Timer","permalink":"http://yoursite.com/tags/Timer/"},{"name":"定时器","slug":"定时器","permalink":"http://yoursite.com/tags/定时器/"}]},{"title":"Qt-文件对话框","slug":"Qt-文件对话框","date":"2018-04-07T07:02:02.594Z","updated":"2018-04-07T07:18:52.657Z","comments":false,"path":"2018/04/07/Qt-文件对话框/","link":"","permalink":"http://yoursite.com/2018/04/07/Qt-文件对话框/","excerpt":"","text":"QFileDialog类参考 选择打开文件12345678910111213141516171819202122232425262728293031323334353637int QtFile_01::OnClickbtnOpen() &#123; //选择要打开的文件 QString fileName = QFileDialog::getOpenFileName(this, GBK::ToUnicode(&quot;Open File打开文件&quot;),//标题 &quot;&quot;, tr(&quot;(*)&quot;));//限制文件类型 //为空时表明用户取消了操作 if (fileName.length() &gt; 0) &#123; qDebug() &lt;&lt; fileName; //Unicode(QString) -&gt; GBK(string) string gbk_name = GBK::FromUnicode(fileName); //打开文件,读取内容 FILE* fp; fopen_s(&amp;fp, gbk_name.c_str(), &quot;rb&quot;); //获取文件大小 fseek(fp, 0, SEEK_END); int filesize = ftell(fp); //读取内容 fseek(fp, 0, SEEK_SET); char* buf = new char[filesize + 1]; int n = fread(buf,1, filesize, fp); if (n &gt; 0) &#123; buf[n] = 0; //显示文本 ui.plainTextEdit-&gt;setPlainText(GBK::ToUnicode(buf)); &#125; //释放内存，关闭界面 delete[]buf; fclose(fp); &#125; return 0;&#125; 保存文件123456789101112131415161718192021222324252627int QtFile_01::OnClickbtnSave() &#123; //选择要保存的位置 QString fileName = QFileDialog::getSaveFileName(this, //父窗口 GBK::ToUnicode(&quot;保存文件&quot;), &quot;/&quot;); //若为空表明用户取消了操作 if (fileName.length() &gt; 0) &#123; //获取文本框中的内容 QString text = ui.plainTextEdit-&gt;toPlainText(); //Unicode(QString) -&gt; GBK(string) string gbk_name = GBK::FromUnicode(fileName); string gbk_text = GBK::FromUnicode(text); //打开文件 FILE* fp; fopen_s(&amp;fp, gbk_name.c_str(), &quot;wb&quot;); //写入文件 fwrite(gbk_text.c_str(), 1, gbk_text.length(), fp); //关闭文件 fclose(fp); &#125; return 0;&#125; 文中ToUnicode()及FromUnicode均为封装好的函数，详见VC下字符编码转换","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"对话框","slug":"对话框","permalink":"http://yoursite.com/tags/对话框/"},{"name":"文件对话框","slug":"文件对话框","permalink":"http://yoursite.com/tags/文件对话框/"}]},{"title":"Qt-模式对话框","slug":"Qt-模式对话框","date":"2018-04-07T07:02:02.592Z","updated":"2018-04-07T07:18:57.515Z","comments":false,"path":"2018/04/07/Qt-模式对话框/","link":"","permalink":"http://yoursite.com/2018/04/07/Qt-模式对话框/","excerpt":"","text":"QDialog类参考 对话框：用于提示用户输入 ####对话框分两种： （1）模式对话框Modal背景界面卡住，用户必须完成对话框输入，关闭对话框之后，才能回到背景界面 （2）非模式对话框Non‐Modal背景界面可以活动。 任务：点登录按钮，弹出对话框提示用户输入。用户点“确认”或“取消”后，回到主界面。(1)新建对话框，布局(2)点确定时，accept() 对话框返回点取消时，reject()对话框返回12345678910111213int LoginDlg::OnbtnOK() &#123; //取得用户的输入 m_user = ui.TextUser-&gt;text(); m_password = ui.TextPassword-&gt;text(); accept();//关闭对话框，并返回Accepted return 0;&#125;int LoginDlg::OnbtnCancel() &#123; //用户取消 reject(); return 0;&#125; (3) 运行对话框 exec()，注意exec()的返回值(4) 取得用户输入123456789101112int QtLog_01::OnbtnOK_1() &#123; //使用对话框 LoginDlg dlg; int ret=dlg.exec();//对话框显示，程序阻塞 if (ret == QDialog::Accepted) &#123; qDebug()&lt;&lt; dlg.m_user &lt;&lt; dlg.m_password;//调试输出 &#125; else &#123; &#125; return 0;&#125; 源码下载 ❤️","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"对话框","slug":"对话框","permalink":"http://yoursite.com/tags/对话框/"},{"name":"模式对话框","slug":"模式对话框","permalink":"http://yoursite.com/tags/模式对话框/"}]},{"title":"Qt-非模式对话框","slug":"Qt-非模式对话框","date":"2018-04-07T07:02:02.586Z","updated":"2018-04-07T07:19:02.609Z","comments":false,"path":"2018/04/07/Qt-非模式对话框/","link":"","permalink":"http://yoursite.com/2018/04/07/Qt-非模式对话框/","excerpt":"","text":"应用实例:搜索框 创建一个Widget对象，作为主窗体的成员变量SearchWindow* m_SearchWin;12m_SearchWin=new SearchWindow(this);m_SearchWin-&gt;setWindowFlags(Qt::Window); 在用户执行搜索菜单时显示此窗口12345int Text_7_4A::ShowSearch() &#123; m_searchWin-&gt;show(); return 0;&#125; 在搜索窗口内有动作时，在主窗口中相应此动作需要将搜索类的ui成员变为public类型 12//响应小窗口内的动作 connect(m_searchWin-&gt;ui.btnStartSearch, SIGNAL(clicked()), this, SLOT(OnStartSearch()) ); 笔芯❤️","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"对话框","slug":"对话框","permalink":"http://yoursite.com/tags/对话框/"},{"name":"非模式对话框","slug":"非模式对话框","permalink":"http://yoursite.com/tags/非模式对话框/"}]},{"title":"Qt的信号和槽","slug":"Qt的信号和槽","date":"2018-04-07T07:02:02.575Z","updated":"2018-04-07T07:11:32.732Z","comments":false,"path":"2018/04/07/Qt的信号和槽/","link":"","permalink":"http://yoursite.com/2018/04/07/Qt的信号和槽/","excerpt":"","text":"信号和槽是Qt特有的信息传输驱动机制，是Qt程序设计中的重要基础，它可以让程序员在互不相干的对象之间建立联系。 槽本质上是类的成员函数，其参数可以是任意类型，它与普通的C++成员函数几乎没有区别，它可以是虚函数；也可以被重载函数；可以是公有的、保护的或私有的，也可以被其它C++成员函数调用，和普通的类成员函数唯一不同的是：槽还可以和信号连接在一起，每当和槽连接的信号被发射时，就会自动调用这个槽。 ###connect()语法形式如下：connect(sender,SIGNAL(signal),receiver,SLOT(slot));这里的sender是发送信号的对象的指针，receiver是包含槽的对象的指针，signal是被发送的信号，slot是接受信号的槽，他们都是不带参数的函数名。SIGNAL()宏和SLOT()宏会把他们的参数转换成相应的字符串。对于信号和槽，还具有以下特点。 ###1.一个信号可以连接多个槽 12connect(sender,SIGNAL(signal),receiver,SLOT(slotA));connect(sender,SIGNAL(signal),receiver,SLOT(slotB)); 当这一信号发射时，会以不确定的顺序一个接一个的调用这个信号连接的所有槽 ###2.多个信号可以连接同一个槽12connect(sender,SIGNAL(signalA),receiver,SLOT(slot));connect(sender,SIGNAL(signalB),receiver,SLOT(slot)); 无论哪个信号被发射，这个槽都会被调用 ###3.一个信号可以连接另外一个信号1connect(sender,SIGNAL(signalA),receiver,SIGNAL(signalB)); 当信号A发射时，也会发射与它相连的信号B ###４.信号、槽之间的连接可以被移除1disconnect(sender,SIGNAL(signal),receiver,SLOT(slot)); 因为删除对象时，Qt会自动移除和这个对象相关的所有连接，所以这个语法很少用到。 除此之外，要把信号成功连接到槽（或者连接到另一个信号），还应该注意，相连接的信号和槽必须具有相同顺序相同类型的参数，如果信号的参数比它所连接的槽的参数多，那么多余的参数将被简单的忽略掉。例如：12connect(sender,SIGNAL(rawCommandReply(int,const QString &amp;)),receiver,SIGNAL(processReply(int , const QString &amp;))); 如果参数类型不匹配，或者信号或槽不存在，尽管应用程序调试构建可能会通过，但Qt会在运行时发出警告。如果信号和槽的名字中包含了参数名，也会发生错误警告 实际上这种机制是在QObject中实现的，这表明信号和槽并不仅仅局限于GUI编程中，实际上这种机制可以用于任何QObject的子类中， 在普通的类中使用信号和槽机制123456789101112131415161718192021Class Circle:public QObject&#123; Q_ONJECT public: Circle()&#123;CircleRadius=0;&#125; int Radius()&#123;return CircleRadius;&#125; public slots: void setRadius(int newRadius); signals: void radiusChanged(int newRadius); private: int circleRadius;&#125;;void Circle::setRadius(int newRadius)&#123; if(newRadius!=circleRadius) &#123; circleRadius=newRadius; emit radiusChanged(circleRadius); &#125;&#125; 来看一下，setRadius()槽是如何工作的。 仔细阅读会发现只有在newRadius不等于circleRadius的时候，才会发射radiusChanged()信号。这样既可以确保信号和槽连接又不会导致无限循环。❤️我的目标是：someday，即便你花钱看我的文章，也会觉得心满意足","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"信号和槽","slug":"信号和槽","permalink":"http://yoursite.com/tags/信号和槽/"}]},{"title":"Qt-QLabe显示文字和图片","slug":"Qt-QLabe显示文字和图片","date":"2018-04-07T07:02:02.461Z","updated":"2018-04-07T07:13:27.489Z","comments":false,"path":"2018/04/07/Qt-QLabe显示文字和图片/","link":"","permalink":"http://yoursite.com/2018/04/07/Qt-QLabe显示文字和图片/","excerpt":"","text":"QLabe Class参考文档 文字与图片的显示格式实际上是用Qt StyleSheet（样式表）设置的与css样式中的差不多 对齐方式 是否换行 设置边框 显示LOGO(显示图片) 添加图片资源 添加一个Labe用来显示图片 ❤️","categories":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/categories/Qt/"}],"tags":[{"name":"Qt","slug":"Qt","permalink":"http://yoursite.com/tags/Qt/"},{"name":"QLabe","slug":"QLabe","permalink":"http://yoursite.com/tags/QLabe/"}]},{"title":"Js Drum Kit","slug":"Js-Drum-Kit","date":"2018-02-26T10:44:18.000Z","updated":"2018-02-26T10:50:35.187Z","comments":true,"path":"2018/02/26/Js-Drum-Kit/","link":"","permalink":"http://yoursite.com/2018/02/26/Js-Drum-Kit/","excerpt":"","text":"html { font-size: 10px; background:url(http://i.imgur.com/b9r5sEL.jpg) bottom center; background-size: cover;}body,html { margin: 0; padding: 0; font-family: sans-serif; -webkit-align-items:center; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; -o-user-select: none; user-select: none;} .keys{ display: flex; flex: 1; min-height: 100vh; justify-content: center; -webkit-justify-content:center; -ms-align-items: center; align-items: center;}.key{ border: 4px black solid; border-radius: 5px; margin: 1rem; font-size: 1.5rem; padding: 1rem 0.5rem; transition: all 0.1s; width: 100px; text-align: center; color: white; text-shadow: 0 0 5px black; background-color:rgba(0,0,0,0.4);}.playing{ transform: scale(1,1); border-color: #ffc600; -webkit-box-shadow: 0 0 10px #ffc600; box-shadow: 0 0 10px #ffc600;}kbd{ display: block; font-size: 40px;}.sound{ color: #FFC600; text-transform: uppercase; font-size: 1.2rem; letter-spacing: 1px;} Aclap S hihat D kick F openhat G boom H ride J snare K tom L tink &lt;audio data-key=&quot;65&quot; src=&quot;sounds/clap.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;83&quot; src=&quot;sounds/hihat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;68&quot; src=&quot;sounds/kick.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;70&quot; src=&quot;sounds/openhat.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;71&quot; src=&quot;sounds/boom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;72&quot; src=&quot;sounds/ride.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;74&quot; src=&quot;sounds/snare.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;75&quot; src=&quot;sounds/tom.wav&quot;&gt;&lt;/audio&gt; &lt;audio data-key=&quot;76&quot; src=&quot;sounds/tink.wav&quot;&gt;&lt;/audio&gt; &lt;script type=&quot;text/javascript&quot;&gt; &apos;use strict&apos;; var keys=document.querySelectorAll(&quot;.key&quot;); window.onkeydown=function(ev){ var keyAudio=document.querySelectorAll(&quot;audio&quot;); for(var i=0;i&lt;keyAudio.length;i++){ if(ev.keyCode==keyAudio[i].attributes[&quot;data-key&quot;].nodeValue){ keyAudio[i].currentTime = 0; keyAudio[i].play(); keys[i].classList.add(&quot;playing&quot;); break; } } } keys.forEach(key =&gt; key.addEventListener(&quot;transitionend&quot;,function(e){ if(e.propertyName !==&apos;border-left-color&apos;) return; e.target.classList.remove(&quot;playing&quot;); })) &lt;/script&gt;","categories":[{"name":"javaScript","slug":"javaScript","permalink":"http://yoursite.com/categories/javaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-02-23T08:12:36.987Z","updated":"2018-04-07T07:19:19.480Z","comments":false,"path":"2018/02/23/hello-world/","link":"","permalink":"http://yoursite.com/2018/02/23/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment * RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS. * LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/ var disqus_config = function () { this.page.url = PAGE_URL; // Replace PAGE_URL with your page's canonical URL variable this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable }; (function() { // DON'T EDIT BELOW THIS LINE var d = document, s = d.createElement('script'); s.src = 'https://nicebluechai.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })(); Please enable JavaScript to view the comments powered by Disqus. (function(){ var appid = 'cytu1mJqc'; var conf = 'prod_724639f82a7493e5cc3377fc5c98c32b'; var width = window.innerWidth || document.documentElement.clientWidth; if (width < 960) { window.document.write(''); } else { var loadJs=function(d,a){var c=document.getElementsByTagName(\"head\")[0]||document.head||document.documentElement;var b=document.createElement(\"script\");b.setAttribute(\"type\",\"text/javascript\");b.setAttribute(\"charset\",\"UTF-8\");b.setAttribute(\"src\",d);if(typeof a===\"function\"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e===\"loaded\"||e===\"complete\"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs(\"http://changyan.sohu.com/upload/changyan.js\",function(){window.changyan.api.config({appid:appid,conf:conf})}); } })();","categories":[{"name":"第一篇","slug":"第一篇","permalink":"http://yoursite.com/categories/第一篇/"},{"name":"Test","slug":"第一篇/Test","permalink":"http://yoursite.com/categories/第一篇/Test/"}],"tags":[{"name":"英文","slug":"英文","permalink":"http://yoursite.com/tags/英文/"}]}]}